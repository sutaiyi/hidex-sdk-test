import t from"./keysing";import{checkAddressChain as e,getUseToken as s,isValidSHA256 as a,numberToCharCode as i,sha256 as r}from"../common/utils";import{deepCopy as o,findAndIncrementMax as n,isValidEthPrivateKey as c,isValidSolanaPrivateKey as l,whosePrivater as h}from"../common/utils";import{defaluBoootedOss as d,defalutWalletStore as w,ENCRYPTION_NAME as y,ETH_SERIES as u,HIDEXKEYWORD as p,NAMES as f}from"../common/config";import{ossStore as g}from"../common/ossStore";import S from"../common/browser/passworder";import{ethers as m}from"ethers";import{Keypair as W}from"@solana/web3.js";import*as E from"bip39";import O from"bs58";import{derivePath as P}from"ed25519-hd-key";import B from"tweetnacl";class b{password;atpkeys;ADDRESS_PATH_TYPE;HS;walletMap=new Map;walletStore;bootedOss;constructor(t){this.password="",this.atpkeys=[],this.HS=t,this.ADDRESS_PATH_TYPE=this.getChainsPath(),this.walletStore=w,this.bootedOss=d}async getCloudBootedOss(t){try{const{apparatus:e}=t,a=s(),i=await g.getBootedOssItem(a,e);if(this.walletMap=g.getWalletMap(),this.bootedOss=i,i.error)throw new Error(i.error);return i}catch(t){throw new Error(t)}}async setCloudBootedOss(t,e,a,i){try{const{apparatus:r}=t,o=s(),n=await g.setBootedOssItem(o,r,e,a,i);return this.walletMap=g.getWalletMap(),this.bootedOss=n,n}catch(t){throw new Error(t)}}async getWalletCatch(t,e){try{const s=await g.getWalletStoreItem(t,e);return this.walletMap=g.getWalletMap(),this.walletStore=this.walletMap.get("WalletStore"),s}catch(t){throw new Error(t)}}async setWalletCatch(t,e,s){await g.setWalletStoreItem(t,e,s),this.walletMap=g.getWalletMap(),this.walletStore=this.walletMap.get("WalletStore")}getWalletStore(){return this.walletStore}async setWalletStore(t){this.walletStore=t,this.setWalletCatch(this.HS.catcher,"all",t)}getBootedOss(){return this.bootedOss}async setBootedOss(t,e){this.bootedOss=t,await this.setCloudBootedOss(this.HS,"all",t,e)}async walletInit(){const t=this.getWalletStore(),e=o(this.getBootedOss());if(console.log("walletInit..."),console.log("walletStore",t),console.log("bootedOss",e),e&&(!t.walletList?.length||t.pathIndex!==e.pathIndex||-1===Object.keys(e.walletBooted).toString().indexOf(t?.walletList[0]?.mnemonic))){console.log("WalletResting..."),await this.HS.catcher.removeItem("dataCache"),await this.setWalletStore(w);const t=e.pathIndex;let s=0;const a=Object.keys(e.walletBooted);for(const e of a)if(e.includes("MNEMONIC_HASH")){s++;const a=e.split("_")[2],i=await this.getEncryptionWallet(this.password,1,a);for(const e of Array.from({length:t+1},(t,e)=>e))console.log("pathIndex",e),await this.createMnemonicWallet(i,e,"",s,!0)}console.log("WalletRested")}}async createPassword(t,e){const s=this.getWalletStore(),a=this.getBootedOss(),i=a?.booted;if(i&&!e)throw new Error(JSON.stringify({code:10009,message:"Password already exists!"}));if(t.length>=256)throw new Error(JSON.stringify({code:1e4,message:"Wrong, < 256 Characters!"}));this.password=await r(t);const o=await S.encrypt(this.password,"true");let n=null;e&&(n=await this.updateWalletBooted(e,a));const c={...s,isUnlocked:!0};return n&&(a.walletBooted=n),a.booted=o,await this.setBootedOss(a),await this.setWalletStore(c),!0}async resetPassword(t,e){if(e.length>=256)throw new Error(JSON.stringify({code:1e4,message:"Wrong, < 256 Characters!"}));return await this.verifyPassword(t),await this.createPassword(e,t),!0}async updateWalletBooted(t,e){let s=t;a(t)||(s=await r(t));const i=e?.walletBooted,o={};if(i&&"object"==typeof i)for(const t of Object.keys(i)){const e=i[t],a=await S.decrypt(s,e);o[t]=await S.encrypt(this.password,a)}return o}async verifyPassword(e){let s=e;a(e)||(s=await r(e));const i=this.getBootedOss().booted;if(!i)throw new Error(JSON.stringify({code:10001,message:"Cannot find password set"}));await S.decrypt(s,i),this.password=s;const o=await this.getUnLockedExpires();t.booted(this.password,this.HS.catcher,o)}async unlock(t){await this.verifyPassword(t),await this.setUnlocked()}async setUnlocked(){await this.setWalletStore({...this.getWalletStore(),isUnlocked:!0})}async setUnLockedExpires(e){if(this.password)return await t.booted(this.password,this.HS.catcher,e),await this.HS.catcher.setItem("unLockedExpiresDay",e||7),!0;throw new Error(JSON.stringify({code:10002,message:"Password is empty"}))}async getUnLockedExpires(){let t=await this.HS.catcher.getItem("unLockedExpiresDay");return t||(t=Number(t)),t||7}async setLocked(){this.password="",t.lock(this.HS.catcher),await this.setWalletStore({...this.getWalletStore(),isUnlocked:!1})}async ownerKey(t){await this.verifyPassword(this.password);return await this.getEncryptionWallet(this.password,0,t)}generateMnemonic(){const t=m.Wallet.createRandom();if(null===t||null===t.mnemonic)return"";return t.mnemonic.phrase}getChainsPath(t=""){const e={};return this.HS.chains().map(s=>{"SOLANA"===t&&"SOLANA"===s.chain&&(e[s.chain]=s.defaultPath),"ETH"===t&&-1!==u.indexOf(s.chain)&&(e[s.chain]=s.defaultPath),t||(e[s.chain]=s.defaultPath)}),e}async createWallet(t,e=0,s="",i=0){if(!a(t)){if(await this.hasWallet())throw new Error(JSON.stringify({code:10018,message:"助记词账户已创建"}))}const r=this.getBootedOss();let o=t;const n=Object.keys(r.walletBooted);if(n.length>0){const t=n.find(t=>t.includes("MNEMONIC_HASH_"));if(t&&t.split("_")[2]!==o)throw new Error(JSON.stringify({code:10018,message:"助记词账户已创建"}));a(o)&&(o=await this.getEncryptionWallet(this.password,1,o))}return await this.createMnemonicWallet(o,e,s,i)}async createMnemonicWallet(t,e=0,s="",a=0,i=!1){await this.verifyPassword(this.password);const n={},c=[];for(const s of Object.keys(this.ADDRESS_PATH_TYPE)){const a=this.getPathByChain(s,e);("SOLANA"===s.toUpperCase()||u.includes(s.toUpperCase()))&&c.push(this.createByMnemonicAndSave(s,t,a.path,e,s))}console.log("createByMnemonicAndSave",c,this.ADDRESS_PATH_TYPE);for(const t of Object.keys(this.ADDRESS_PATH_TYPE)){let e={};if("SOLANA"===t)e=c.find(t=>"SOLANA"===t.chain.toUpperCase());else{const s=c.find(t=>u.includes(t.chain));s&&(e=o(s),e.chain=t)}n[t]=e;const s=JSON.parse(JSON.stringify(e));("SOLANA"===t.toUpperCase()||u.includes(t.toUpperCase()))&&this.atpkeys.push(this.setEncryptionWallet(this.password,0,s.address,s.privateKey)),n[t]&&n[t].privateKey&&delete n[t].privateKey}const l=await r(t);this.atpkeys.push(this.setEncryptionWallet(this.password,1,l,t)),n.id=e;const h={mnemonic:l,usePrivateKey:!1,accountList:[n],id:a};return await this.setWalletList(h,e,s,i)}async createPrivateWallet(t){await this.verifyPassword(this.password);const e={};if(!c(t)&&!l(t))throw new Error(JSON.stringify({code:10002,message:"Invalid private key"}));const s=h(t);let a="";const i=this.getChainsPath(s);for(const r in Object.keys(i)){const o=Object.keys(i)[r],n=await this.createByPrivate(),c=await n[o.toUpperCase()](t,o,s);a+=c.address,e[o]=c,await this.setEncryptionWallet(this.password,0,c.address,c.privateKey),delete e[o].privateKey}e.id=0,e.key=a,e.whoChain=s;const r={mnemonic:"",usePrivateKey:!0,accountList:[e],id:0};return await this.setWalletList(r)}async setWalletList(t,e=0,s="",a=!1){const r=this.getWalletList()||[],c=o(r);let l=t;if(l.isRepeat=!1,t.mnemonic){const e=c.find(e=>e.mnemonic===t.mnemonic);if(e){if(-1!==e.accountList.findIndex(e=>e.id===t.accountList[0].id))return Object.assign(e,{isRepeat:!0});e.accountList.push(...t.accountList)}else{const e=c.find(t=>t.usePrivateKey)?c.length:c.length+1;t.walletName=s||`${f.walletName}${i(e)}`,t.id=n(c.map(t=>t.id)),c.push(t)}}else if(t.usePrivateKey){const e=c.find(e=>e.usePrivateKey===t.usePrivateKey),s=t?.accountList[0],a=await this.getWalletByAddress(s[s.whoChain||"ETH"].address);if(e){e.accountList.find(t=>t.key===s.key)||a.has&&void 0!==a.walletId&&void 0!==a.accountId?l.isRepeat=!0:(t.accountList[0].id=n(e.accountList.map(t=>t.id)),l.id=e.id,e.accountList.push(...t.accountList))}else t.walletName=f.usePrividerName,a.has&&void 0!==a.walletId&&void 0!==a.accountId?l.isRepeat=!0:(t.id=n(c.map(t=>t.id)),c.push(t),l=t)}if(!l.isRepeat){let t=[];if(!a){t=await Promise.all(this.atpkeys);const s={...this.getBootedOss(),pathIndex:e};t[t.length-1]&&(s.walletBooted=t[t.length-1]),await this.setBootedOss(s)}await this.setWalletStore({...this.getWalletStore(),walletList:c,pathIndex:e})}return this.atpkeys=[],l}async setWalletName(t,e){const s=await this.getWalletById(t),a=o(s);return a.walletName=e,this.updatedWallet(a),!0}async updatedWallet(t){const e=this.getWalletList()||[],s=o(e),a=s.find(e=>e.id===t.id);if(a)return Object.assign(a,t),await this.setWalletStore({...this.getWalletStore(),walletList:s}),t;throw new Error("wallet not found")}async getWalletByAddress(t){const e=this.getWalletList()||[],s=o(e);if(0===s.length)return{has:!1};for(const e of s)for(const s of e.accountList)for(const a of Object.keys(s))if(s[a]&&"object"==typeof s[a]&&s[a].address===t)return{has:!0,walletId:e.id,accountId:s.id};return{has:!1}}getWalletList(){return(this.getWalletStore()||{}).walletList||[]}async getCurrentWallet(){const t=this.getBootedOss(),[e,s]=t.currentWalletId?.split("&"),a=await this.getWalletById(Number(e));let i=a.accountList.find(t=>t.id===Number(s));if(i||(i=a.accountList[0]),a&&i)return{walletItem:a,accountItem:i};throw new Error(JSON.stringify({code:10003,message:"Getting wallet error"}))}async getWalletById(t){try{const e=this.getWalletList().find(e=>e.id===Number(t));return e||this.getDefaultWallet()}catch(t){throw new Error(JSON.stringify({code:10004,message:"Wallet not found"}))}}async getDefaultWallet(){try{const t=this.getWalletList()[0];if(t)return t;throw new Error(JSON.stringify({code:10004,message:"Wallet not found"}))}catch(t){throw t}}async getWalletAndAccount(t,e){const s=await this.getWalletById(t),a=s.accountList.find(t=>t.id===e);if(!a)throw new Error(JSON.stringify({code:10005,message:"Account not found"}));const i=o(s);return i.accountList=[a],i}async getAccountById(t,e){const s=(await this.getWalletById(t)).accountList.find(t=>t.id===Number(e));if(!s)throw new Error(JSON.stringify({code:10005,message:"Account not found"}));return s}async getWalletCurrentPathIndex(){const t=await this.getCloudBootedOss(this.HS);return t?.pathIndex||0}async setCurrentWallet(t=0,e=0){return await this.setBootedOss({...this.getBootedOss(),currentWalletId:`${t}&${e}`}),await this.getCurrentWallet()}async deleteWallet(t,e){try{await this.verifyPassword(t);const s=this.getWalletList()||[],a=o(s),i=a.findIndex(t=>t.id===e);if(-1!==i)return a.splice(i,1),await this.setWalletStore({...this.getWalletStore(),walletList:a}),!0;throw new Error("wallet not found")}catch(t){throw new Error(t.message)}}async deleteWalletAccount(t,e,s){try{await this.verifyPassword(t);const a=this.getWalletList()||[],i=o(a),r=i.find(t=>t.id===e);if(r){const a=r.accountList.findIndex(t=>t.id===s);if(-1!==a)return r.accountList.splice(a,1),0===r.accountList.length?(await this.deleteWallet(t,e),!0):(await this.setWalletStore({...this.getWalletStore(),walletList:i}),!0);throw new Error("account not found")}throw new Error("wallet not found")}catch(t){throw new Error(t.message)}}async clearWallet(){if(await this.clearLocalWallet()){const t=!0;await this.setBootedOss(d,t)}return this.password="",!0}async clearLocalWallet(){return console.log("clearLocalWallet...."),await this.setWalletStore(w),await this.HS.catcher.removeItem("dataStorage"),await this.HS.catcher.removeItem("dataCache"),await this.HS.catcher.removeIdbItem("dataStorage"),await this.HS.catcher.removeCookie("dataStorage",{secure:!0,path:"/"}),g.clearWalletMap(),this.walletStore=w,this.bootedOss=d,this.password="",console.log("clearLocalWallet success"),!0}eventSecretCode(){const e=e=>{this.password=e||t.get(),this.password||this.setLocked()};e(""),t.on("EventSecretCode",e)}async exportMnemonics(t,e){await this.verifyPassword(t);const s=await this.getWalletById(e);if(s.mnemonic)return await this.getEncryptionWallet(this.password,1,s.mnemonic);throw new Error("mnemonic not found")}async exportPrivateKey(t,e,s,a){try{await this.verifyPassword(t);const i=(await this.getWalletById(e)).accountList.find(t=>t.id===s);if(i){const t=await this.ownerKey(i[a].address);if(t)return t}throw new Error("account not found")}catch(t){throw console.error(t),t}}async getEncryptionWallet(t,e,s){const a=this.getBootedOss().walletBooted;if(a){const i=a[`${y[e]}${s.toLowerCase()}`];if(i)return await S.decrypt(t,i)}return""}async setEncryptionWallet(t,e,s,a){try{const i=this.getBootedOss().walletBooted||{},r=y,o=await S.encrypt(t,a);return i[`${r[e]}${s.toLowerCase()}`]=o,i}catch(t){return console.error("setEncryptionWallet - error",t),{}}}getPathByChain(t,e=0){let s=this.ADDRESS_PATH_TYPE[t];return e&&(s=s.replace(/\/0$/,`/${e}`)),{path:s}}createByMnemonicAndSave(t,e,s,a,i){return"SOLANA"===t?this.createByMnemonicFunBySol(e,a,i):this.createByMnemonicFun(e,s,a,i)}createByMnemonicFun(t,e,s,a){const i=m.utils.HDNode.fromMnemonic(t).derivePath(e),{address:r,privateKey:o,publicKey:n}=i;return console.log("---账户创建---",{pathIndex:s,path:e,address:r,publicKey:n,privateKey:o,chain:a,block:0}),{pathIndex:s,path:e,address:r,publicKey:n,privateKey:o,chain:a,block:0}}createByMnemonicFunBySol(t,e,s){const a=`${this.ADDRESS_PATH_TYPE[s].replace(/0'(?=\/0$)/,`${e}'`)}'`,i=E.mnemonicToSeedSync(t),r=P(a,i.toString("hex")).key,o=W.fromSeed(r),n=o.publicKey.toString();return{pathIndex:e,path:a,address:n,publicKey:n,privateKey:O.encode(Buffer.from(o.secretKey)),chain:"SOLANA",block:0}}async createByPrivate(){return{ETH:async(t,e,s)=>{if(e)return await this.createEthSeriesPrivateKey(t,e,s,"ETH")},BASE:async(t,e,s)=>{if(e)return await this.createEthSeriesPrivateKey(t,"ETH",s,"BASE")},ARBITRUM:async(t,e,s)=>{if(e)return await this.createEthSeriesPrivateKey(t,"ETH",s,"ARBITRUM")},BSC:async(t,e,s)=>{if(e)return await this.createEthSeriesPrivateKey(t,"ETH",s,"BSC")},SEPOLIA:async(t,e,s)=>{if(e)return await this.createEthSeriesPrivateKey(t,"ETH",s,"SEPOLIA")},SOLANA:async(t,e,s)=>{if(e===s){const e=O.decode(t),a=W.fromSecretKey(e),{publicKey:i}=a,r=i.toBase58();return{pathIndex:0,path:"",privateKey:t,address:r,publicKey:r,chain:s,block:0}}{const e="SOLANA",{address:s,publicKey:a,outPrivateKey:i,block:r}=await this.generatePrivateKeyByChain(t,e);return{pathIndex:0,path:"",address:s,publicKey:a,privateKey:i,chain:e,block:r}}}}}async createEthSeriesPrivateKey(t,e,s,a){if(e===s){t.startsWith("0x")||(t="0x"+t);const e=0,s=new m.Wallet(t),{address:i,publicKey:r}=s;return{pathIndex:0,path:"",address:i,publicKey:r,privateKey:t,chain:a,block:e}}{const{address:s,publicKey:i,outPrivateKey:r,block:o}=await this.generatePrivateKeyByChain(t,e);return{pathIndex:0,path:"",address:s,publicKey:i,privateKey:r,chain:a,block:o}}}async generatePrivateKeyByChain(t,e){let s={address:"",outPrivateKey:"",publicKey:"",block:0};if("SOLANA"===e){const e=new m.Wallet(t),a=Uint8Array.from(Buffer.from(e.privateKey.slice(2),"hex")),i=W.fromSeed(a.slice(0,32)),r=i.secretKey,o=O.encode(r),n=i.publicKey.toBase58();s={address:n,publicKey:n,outPrivateKey:o,block:0}}if(-1!==u.indexOf(e.toUpperCase())){const e=O.decode(t),a=W.fromSecretKey(e).secretKey.slice(0,32),i=Buffer.from(a),r=new m.Wallet(i),o=r.address,n=r.privateKey,c=0;s={address:o,outPrivateKey:n,publicKey:this.getPublicKey(n),block:c}}return s}getPublicKey(t){return new m.Wallet(t).publicKey}async isUnlocked(){return await t.isLocked(this.HS.catcher)?this.getWalletStore().isUnlocked:(this.setWalletStore({...this.getWalletStore(),isUnlocked:!1}),!1)}async isSetPassword(){return(await this.getWalletStatus()).isSetPassword}async hasWallet(){return(await this.getWalletStatus()).hasWallet}async getWalletStatus(){const[t,{pathIndex:e,walletStatus:s,passwordStatus:a}]=await Promise.all([this.isUnlocked(),this.getCloudBootedOss(this.HS)]);return{isUnlocked:t,isSetPassword:a,pathIndex:e||0,hasWallet:s}}async signMessage(t,s){const a=await this.ownerKey(s);if("ETH"===e(s)){const e=new m.Wallet(a);return await e.signMessage(t)}const i=(new TextEncoder).encode(t),r=B.sign.detached(i,this.HS.utils.ownerKeypair(a).secretKey);return O.encode(r)}async decryptionS3Data(t,e){const s=await S.decrypt(e,t);console.log("encryptedWallet",s)}}export default b;