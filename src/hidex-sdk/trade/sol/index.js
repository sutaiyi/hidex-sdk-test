import{PublicKey as t,SystemProgram as e}from"@solana/web3.js";import{smTokenAddress as a}from"../../common/config";import{getTokenOwner as s,hashFailedMessage as r,sendSolanaTransaction as o,vertransactionsToBase64 as n}from"./utils";import{AccountLayout as i,ASSOCIATED_TOKEN_PROGRAM_ID as c,createAssociatedTokenAccountInstruction as u,createTransferInstruction as l,getAssociatedTokenAddress as m,TOKEN_2022_PROGRAM_ID as h,TOKEN_PROGRAM_ID as w}from"@solana/spl-token";import{simulateConfig as p,TOKEN_2022_OWNER as g}from"./config";import{priorityFeeInstruction as d}from"./instruction/InstructionCreator";import y from"./defiApi";import f from"../../utils/UtilsService";import{compileTransactionByAddressLookup as S,getAddressLookup as P,getClainSignature as A,getTransactionsSignatureArray as v}from"./instruction";import{NETWORK_FEE_RATES as C}from"../eth/config";import{getWithdrawSign as B}from"../../api/hidex";import{setStatistics as k}from"../../utils/timeStatistics";const b=new f;export const solService=f=>{const{network:L,wallet:N}=f,F=async(e,r="",o=!1)=>{const n=L.get(102);try{if(r&&r===a||!r||o){const a=new t(o?r:e),s=L.sysProviderRpcs[n.chain].map(t=>t.getBalance(a).then(t=>t).catch(t=>Promise.reject(t))),i=await Promise.any(s);return i.error?o?"-1":"0":i.toString()}const i=new t(e),u=new t(r),l=await L.getProviderByChain(102),w=await s(r,l);let p=await m(u,i,!1);w===g&&(p=await m(u,i,!1,h,c));const d=L.sysProviderRpcs[n.chain].map(t=>t.getTokenAccountBalance(p).then(t=>t).catch(t=>Promise.reject(t))),y=await Promise.any(d);return y.error?o?"-1":"0":y.value.amount}catch(t){return console.error(t),o?"-1":"0"}};return{getBalance:F,getBalanceMultiple:async(e,s,r)=>{const o=r.map(e=>e.toLowerCase()===a.toLowerCase()?new t(s):m(new t(e),new t(s),!1,w)),n=await Promise.all(o),c=L.sysProviderRpcs[e].map(t=>t.getMultipleAccountsInfo(n).then(t=>t).catch(t=>Promise.reject(t))),u=await Promise.any(c),l=[];return u.forEach(t=>{if(t)if(t.data&&t.data.length){const e=i.decode(t.data);l.push(e.amount.toString())}else l.push(t.lamports.toString());else l.push("0")}),l},getNetWorkFees:async(t,e)=>{const a=[];let s=3!==e?.0055:.003,r=3!==e?C.SOLANA_JITO:C.SOLANA;10===e&&(s=1e-5,r=C.SOLANA_SEND);for(let e=0;e<r.length;e++)a.push({value:Number((s*r[e]).toFixed(5)),unit:"SOL",gasLimit:t,gasPrice:5e-6.toString(),rate:r[e]});return a},getAllowance:async()=>1e4,toApprove:async()=>!0,getSendEstimateGas:async()=>({gasLimit:1e5}),getSendFees:async(t,e,a)=>{const s=t.value,r=1e4/Math.pow(10,9);let o=0;const n=await F(e,a);0===Number(n)&&(o=2039280/Math.pow(10,9));return s+0+890880/Math.pow(10,9)+r+o},sendTransaction:async r=>{const{from:n,to:i,amount:p,tokenAddress:y,currentNetWorkFee:f}=r;try{let r=await N.ownerKey(n);const S=b.ownerKeypair(r).publicKey,P=new t(i),A=[],v=await L.getFastestProviderByChain(102);if(y&&y.toLowerCase()!==a.toLowerCase()){const e=new t(y),a=await s(y,v)===g,r=await m(e,S,!1,a?h:w,c),o=await m(e,P,!1,a?h:w,c),n=await v.getAccountInfo(o);null!=n&&0!=n.data.length||A.push(u(S,o,P,e,a?h:w,c)),A.push(l(r,o,S,BigInt(p),[],a?h:w))}else A.push(e.transfer({fromPubkey:S,toPubkey:P,lamports:BigInt(p)}));const C=await d(2e5,f.value);A.unshift(...C);const{blockhash:B}=await v.getLatestBlockhash(),k=await o(v,b.ownerKeypair(r),A,B);return console.timeEnd("sendTransaction"),r="",{error:null,result:{hash:k,message:"SUCCESS"}}}catch(t){return{error:t,result:null}}},getSwapPath:async t=>{if(parseFloat(t.amountIn)<=0)throw new Error("amountIn must be greater than 0");let e=0;if(t.isBuy&&t.currentPrice){const a=Number(t.amountIn)/Math.pow(10,t.in.decimals)*t.cryptoPriceUSD;e=Math.floor(a/Number(t.currentPrice)*Math.pow(10,t.out.decimals))}return!t.isBuy&&t.currentPrice&&(e=Math.floor(Number(t.amountIn)/Math.pow(10,t.in.decimals)*t.currentPrice/t.cryptoPriceUSD*Math.pow(10,t.out.decimals))),{fullAmoutOut:BigInt(e).toString(),data:null}},getSwapEstimateGas:async(t,e,a)=>{const{compile:s}=t;let r=s,o=[];console.log("------------isGetAddressLookup------------------",!!r?.addressesLookup),k({timerKey:"SwapRoute",isBegin:!0});const{success:n,swapTransaction:i,data:c,outAmount:u,recentBlockhash:l}=await y.swapRoute(t,a);if(t.amountOutMin=u,k({timerKey:"SwapRoute",isBegin:!1}),!n)throw new Error("Failed to swap_get_router"+JSON.stringify(t)+e);if(r?.addressesLookup&&i){const{message:e,addressesLookup:s}=await S(i,r?.addressesLookup,f);o=await v(e,s,l,t,f.utils.ownerKeypair(await N.ownerKey(a)),f)}if(console.log("txArray",o),0===o.length){k({timerKey:"CompileTransaction",isBegin:!0}),r=await P(i,f),t.preAmountIn=c.inAmount,t.preAmountOut=c.otherAmountThreshold;const{message:e,addressesLookup:s}=await S(i,r?.addressesLookup,f);o=await v(e,s,l,t,f.utils.ownerKeypair(await N.ownerKey(a)),f),k({timerKey:"CompileTransaction",isBegin:!1}),console.timeEnd("AgainRouterTimer")}if(0===o.length)throw new Error("Failed to swap txArray is empty"+JSON.stringify(t));return console.log("txArray: ===>",o),{gasLimit:0,data:{vertransactions:o}}},getSwapFees:async t=>{const{networkFee:e}=t;return.00122+4278560/Math.pow(10,9)+890880/Math.pow(10,9)+(e?.value||Number(t.priorityFee)/Math.pow(10,9))},swap:async(t,e,a)=>{k({timerKey:"SubmitSwap",isBegin:!0});const{vertransactions:s}=e?.data,r=await y.submitSwapByAllPlatforms(t,s);return k({timerKey:"SubmitSwap",isBegin:!1}),{error:!r.success,result:{hashs:r.hashs,data:{blox_vertransactions:n(s[0]),vertransactions:n(s[0]),flash_vertransactions:n(s[1]),accountAddress:a,currentSymbol:t,...r}}}},hashStatus:async(t,e)=>{try{const a=L.getProviderByChain(e||102),s=()=>y.getSwapStatus(t),o=()=>y.rpcHeliusSwapStatus(t),n=()=>y.rpcSwapStatus(t,a),i=await Promise.any([s(),n(),o()]);console.log("SOL状态查询===》",["GMGN","RPC"],i);let c="HashStatus...";return"Failed"===i&&(c=await r(a,t)),{status:i,message:c}}catch(t){return{status:"Pending",message:"HashStatus Pending"}}},hashsStatus:async(t,e)=>{try{const a=L.getProviderByChain(e||102),s=async(t,e)=>{const s=(await Promise.allSettled([y.getSwapStatus(t),y.rpcSwapStatus(t,a)])).filter(t=>"fulfilled"===t.status).map(t=>{const e=t.value;return"string"==typeof e?e:e?.status});return s.includes("Confirmed")?{hashStatus:"Confirmed",hashGroup:e}:s.includes("Failed")?{hashStatus:"Failed",hashGroup:e}:{hashStatus:"Pending",hashGroup:e}},o=t.map(async t=>await s(t[0],t)),n=await Promise.all(o);if(n.find(t=>"Confirmed"===t.hashStatus))return{status:"Confirmed",message:{successHash:n?.filter(t=>"Confirmed"===t.hashStatus)[0]?.hashGroup}};if(n.filter(t=>"Failed"===t.hashStatus).length>=2){return{status:"Failed",message:await r(a,t[0][0])}}return{status:"Pending",message:"Some hash groups pending"}}catch(t){return{status:"Pending",message:"HashStatus Pending"}}},claimCommission:async t=>{try{const e=await B(t);if(console.log("withdrawRes",t,e),200===e.code&&e.data){const a=L.getProviderByChain(102),{blockhash:s}=y.lastBlockHash,{signer:r,contents:o,signature:n}=e.data,i=await A(r,o.substring(2),n.substring(2),s,f.utils.ownerKeypair(await N.ownerKey(t.walletAddress)),f),c=await a.simulateTransaction(i,p);if(console.log("领取 预估结果==>",c),c?.value?.err)return{code:4001,message:"Claim commission error in simulateTransaction: "+JSON.stringify(c?.value?.logs+JSON.stringify(c?.value?.err)),data:null};const u=i.serialize();return{code:200,message:"Claim commission success",data:null,txhash:await a.sendRawTransaction(u,{preflightCommitment:"confirmed"})}}return e}catch(t){return{code:4001,message:"Claim commission error: "+JSON.stringify(t),data:null}}}}};