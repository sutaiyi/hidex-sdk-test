import{TransactionMessage as t,VersionedTransaction as o,AddressLookupTableAccount as e,PublicKey as s}from"@solana/web3.js";import{SOLANA_SYSTEM_PROGRAM_ID as n,SOLANA_SYSTEM_PROGRAM_TRANSFER_ID as a,SOLANA_CREATE_ACCOUNT_WITH_SEED_ID as i,JITO_FEE_ACCOUNT as r,SOLANA_MAX_TX_SERIALIZE_SIGN as l,NEED_CHANGE_SLIPPAGE_PROGRAM_IDS as c,SUPPORT_CHANGE_PROGRAM_IDS as u,PUMP_AMM_PROGRAM_ID as g,VERSION_TRANSACTION_PREFIX as p,PRE_PAID_EXPENSES as d,DEFAULD_SOLANA_GAS_LIMIT as m,COMMISSION_SOLANA_GAS_LIMIT as f,HIDEX_ADDRESS_LOOK_UP as h,BLOXROUTE as B,Trading_Service_Providers as w,PUMP_PROGRAM_ID as I}from"../config";import{checkAccountCloseInstruction as y,createClaimInstruction as A,createEd25519ProgramIx as k,createMemoInstructionWithTxInfo as b,createTipTransferInstruction as L,createTradeNonceVerifyInstruction as S,deleteTipCurrentInInstructions as x,deleteTransactionGasInstruction as T,getDexCommisionReceiverAndLamports as E,getInstructionAmounts as K,getInstructionReplaceDataHex as O,getTipAndPriorityByUserPriorityFee as P,getTradeNonce as N,getTransactionGasLimitUintsInInstruction as _,nomalVersionedTransaction as M,numberToLittleEndianHex as z,priorityFeeInstruction as C,setCreateAccountBySeedInstructionLamports as U,setTransferInstructionLamports as v,versionedTra as F}from"./InstructionCreator";import{createMemoInstruction as R}from"@solana/spl-memo";export function resetInstructions(t,o,e,s){console.log("传入的输出代币数量",s),console.log("传入的输入代币数量",e);let r=-1;for(let l=0;l<o.instructions.length;l++){const p=o.instructions[l];let m=p.data.toString("hex"),f=!1;if(0==p.data.length)continue;const h=p.data.readUint8();p.programId.toBase58()==n.toBase58()&&t.isBuy&&l!=o.instructions.length-1&&l!=o.instructions.length-2&&(f=v(p,m,e),f&&(r=l,console.log("转账指令已修改 = "+r))),p.programId.toBase58()==n.toBase58()&&h==i&&(console.log(p.data.length),f=U(t.preAmountIn,p,m,e),f&&(r=l,console.log("CreateAccountBySeed指令已修改 = "+r)));if((u.get(p.programId.toBase58())??0)>0){const n=K(t,p);console.log("修改前输入的代币数量 = "+n.input),console.log("修改前输出的代币数量 = "+n.output);const l=BigInt(1e4);let u=BigInt(Math.round(t.slipPersent*Number(l)));if(-1==c.indexOf(p.programId.toBase58()))if(p.programId.toBase58()==g.toBase58()&&t.isBuy){const n=e;e+=e*u/l,console.log("增加滑点量后传入的输入代币数量",e);const c=BigInt(t.solLamports)-BigInt(d)-BigInt(t.priorityFee);if(console.log("当前用户余额",t.solLamports),console.log("可用于购买PUMP.amm的余额",c),e>c&&(s=s*c/e,console.log("余额不足，总量下移后购买的代币量",s),e=c,console.log("余额不足，总量下移后消耗的sol",e)),console.log("transferInstructionIndex = "+r),r>0){const t=o.instructions[r],s=t.data.toString("hex"),l=t.data.readUInt32LE(0);l===a?(console.log("转账指令重新修改为：",e),v(t,s,e)):l==i&&(console.log("SOLANA_CREATE_ACCOUNT_WITH_SEED指令重新修改为：",e),U(n.toString(),t,s,e))}if(e>BigInt(c))throw new Error("Error: pump-amm insufficient account balance "+t.solLamports+" for required input "+e)}else s-=s*u/l,console.log("newOutputAmount",s);else{console.log("滑点修改前 changeSlippageData = ",m);const t=m.slice(m.length-6).match(/.{2}/g)?.reverse().join("")||"",o=BigInt("0x"+t);console.log("修改前滑点值 = ",o);const e=z(Number(u),3);m=m.slice(0,m.length-6)+e,console.log("滑点指令后 tempInstruction = ",p.data.toString("hex"))}console.log("滑点 = "+t.slipPersent);const f=Buffer.alloc(8);f.writeBigUInt64LE(e);const h=f.toString("hex");console.log("计算滑点后输入的代币数量 = "+e),f.writeBigUInt64LE(s);const B=f.toString("hex");console.log("计算滑点后输出的代币数量 = "+s),console.log("修改前data = ",p.data.toString("hex"));let w=O(t,p.programId.toBase58(),m,h,B);console.log("finalData = "+w),p.data=Buffer.from(w,"hex"),console.log("data3 = "+p.data.toString("hex"))}}return o}export async function compileTransaction(n,a){if(!n.startsWith(p))throw new Error("This token type does not support transactions");const i=Buffer.from(n,"base64"),l=o.deserialize(i),c=l.message.addressTableLookups.map(t=>t.accountKey);console.log("addressLookupTableAccounts1",c.length),c.push(h);const u=a.network.getProviderByChain(102),g=await u.getMultipleAccountsInfo(c),d=new Array(c.length);for(let t=0;t<g.length;t++){const o=e.deserialize(g[t].data);for(let t=0;t<o.addresses.length;t++)-1!==r.indexOf(o.addresses[t].toBase58())&&(o.addresses[t]=new s("So11111111111111111111111111111111111111112"));const n=new e({key:c[t],state:o});0!=g[t].data.length&&(d[t]=n)}const m=t.decompile(l.message,{addressLookupTableAccounts:d});console.log("programId",m.instructions[0].programId.toBase58()),console.log("addressLookupTableAccounts2",d.length);const f=[],B=await u.getSlot();for(let t=0;t<d.length;t++)B<d[t].state.deactivationSlot&&f.push(d[t]);return console.log("validAddressLookupTableAccounts3",f.length),{message:m,addressesLookup:f}}export async function compileTransactionByAddressLookup(e,s,n){if(!e.startsWith(p))throw new Error("This token type does not support transactions");const a=Buffer.from(e,"base64"),i=o.deserialize(a);let r=i.message.addressTableLookups,l=!0;for(let t=0;t<r.length;t++)r[t].accountKey.toBase58()!=s[t].key.toBase58()&&(console.log("两个地址映射不一致，重新获取",r[t].accountKey.toBase58(),s[t].key.toBase58()),l=!1);if(l){return{message:t.decompile(i.message,{addressLookupTableAccounts:s}),addressesLookup:s}}{console.log("两个地址映射不一致，重新获取");let t=await compileTransaction(e,n);return{message:t.message,addressesLookup:t.addressesLookup}}}export async function getAddressLookup(t,n){if(!t.startsWith(p))throw new Error("This token type does not support transactions");const a=Buffer.from(t,"base64"),i=o.deserialize(a).message.addressTableLookups.map(t=>t.accountKey);console.log("addressLookupTableAccounts1",i.length),i.push(h);const l=n.network.getProviderByChain(102),c=await l.getMultipleAccountsInfo(i),u=new Array(i.length);for(let t=0;t<c.length;t++){const o=e.deserialize(c[t].data);for(let t=0;t<o.addresses.length;t++)-1!==r.indexOf(o.addresses[t].toBase58())&&(o.addresses[t]=new s("So11111111111111111111111111111111111111112"));const n=new e({key:i[t],state:o});0!=c[t].data.length&&(u[t]=n)}const g=[],d=await l.getSlot();for(let t=0;t<u.length;t++)d<u[t].state.deactivationSlot&&g.push(u[t]);return console.log("validAddressLookupTableAccounts3",g.length),{addressesLookup:g}}export function getActualLamports(e,s,n){let a=BigInt(e.amountIn);if(!e.isBuy)return a;const i=Buffer.from(s,"base64"),r=o.deserialize(i);let l=!1;const c=t.decompile(r.message,{addressLookupTableAccounts:n});for(let t=0;t<c.instructions.length;t++){const o=c.instructions[t].programId.toBase58();if(console.log("programId",o),o==I.toBase58()||o==g.toBase58()){l=!0;break}}if(l){const t=BigInt(1e4);let o=a+a*BigInt(Math.round(e.slipPersent*Number(t)))/t;const s=BigInt(e.solLamports)-BigInt(d)-BigInt(e.priorityFee);return console.log("当前用户余额",e.solLamports),console.log("可用于购买PUMP.amm的余额",s),o>s&&(a=s*BigInt(10)/BigInt(10*(1+e.slipPersent)),console.log("余额不足，总量下移后消耗的sol",a)),a}}export function isInstructionsSupportReset(t,o){for(let e=0;e<t.instructions.length;e++){const s=t.instructions[e],n=s.programId.toBase58();console.log("dexId",n),console.log("********************************************************************************");if((u.get(n)??0)>0){console.log("data",s.data.toString("hex"));const t=K(o,s);console.log("检测指令中输入的代币数量 = "+t.input),console.log("检测指令中输出的代币数量 = "+t.output),console.log("外部传入的预请求输入的代币数量 = "+BigInt(o.preAmountIn)),console.log("外部传入的预请求输出的代币数量 = "+BigInt(o.preAmountOut));let e=BigInt(o.preAmountIn),n=BigInt(o.preAmountOut);if(t.input==e||t.output==n)return console.log("买入指令检测成功 = "+t.input),!0}}return!1}export async function getClainSignature(t,o,e,s,n,a){const i=o.substring(o.length-64);let r=Buffer.from(i,"hex").toString()+n.publicKey.toBase58();const l=await R(r),[c,u]=await C(f,m),g=await k(t,o,e),p=await A(o,e,n,a.network);return await M([g,c,u,p,l],n,s)}export async function getTransactionsSignature(t,o,e,i,r,c){for(let o=0;o<t.instructions.length;o++){if(await y(i,t.instructions[o],r,c.network)){t.instructions.splice(o,1);break}}for(let o=t.instructions.length-1;o>t.instructions.length-3;o--){const e=t.instructions[o];if(e.programId.toBase58()==n.toBase58()){e.data.readUInt32LE(0)===a&&(console.log("SOLANA_SYSTEM_PROGRAM_TRANSFER_ID"),t.instructions.splice(t.instructions.length-1))}}let u=Number(i.priorityFee);const g=_(t.instructions);console.log("gasLimitInIX",g),await T(t.instructions);const p=[...t.instructions],d=b(i);t.instructions.push(d);const{swap_pda:f,commissionAmount:h}=await E(i),w=await L(r.publicKey,f,BigInt(h));t.instructions.push(w);const I=await L(r.publicKey,B,BigInt(.5*u));t.instructions.push(I);const[A,k]=await C(1.5*g,.5*u);t.instructions.splice(0,0,A),t.instructions.splice(0,0,k);const S=await F([...t.instructions],r,e,o),x=S.serialize().length;if(console.log("交易串字节长度 = "+x),x<l)return[S];{const[t,n]=await C(g,m),a=await F([t,n],r,e,o),l=await F(p,r,e,o),c=await F([w,d],r,e,o),u=await L(r.publicKey,new s(B),BigInt(i.priorityFee));return[a,l,c,await F([u],r,e,[])]}}export async function getOwnerTradeNonce(t,o){return N(t,o.network)}export async function getTransactionsSignatureArray(t,o,e,s,n,a){const i=_(t.instructions);console.log("gasLimitInIx",i),x(t),T(t.instructions);let r=Number(s.priorityFee);const{tipAmount:c,priorityAmount:u}=P(r),[g,p]=await C(1.2*i,u),d=Math.floor(Date.now()/1e3);console.log("timestamp",d);const m=await S(d,n,a.network),f=b(s),{swap_pda:h,commissionAmount:B}=await E(s),I=await L(n.publicKey,h,BigInt(B));let y=[];for(let s=0;s<w.length;s++){const a=[...t.instructions];a.push(f),a.push(I),a.push(m);const i=await L(n.publicKey,w[s],BigInt(c));let r;a.push(i),a.splice(0,0,g),a.splice(0,0,p),console.log("准备系列化");let u,d=0;try{u=await F(a,n,e,o),r=u.serialize(),d=r.length}catch{}if(console.log("交易串字节长度 = "+d),u&&d>0&&d<l)y.push([u]);else{console.log("进入大指令");const a=[...t.instructions],i=await F([g,p],n,e,o),r=await F(a,n,e,o),l=await F([I,f,m],n,e,o),u=await L(n.publicKey,w[s],BigInt(c)),d=await F([u],n,e,[]);y.push([i,r,l,d])}}return y}