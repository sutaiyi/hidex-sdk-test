import s from"axios";import t from"bs58";import{Connection as e}from"@solana/web3.js";import{JITO_SEND_URL as a,QUIKNODE_SEND_URL as r}from"./config";import{urlPattern as o}from"./utils";import{axiosErrorMessage as n}from"../../common/utils";import{getSolanaRpcHeard as i}from"../../network/utils";class c{clearTimer;maxBlockHashCount;currentBlockHashCount;lastBlockHash;constructor(){this.clearTimer=null,this.lastBlockHash={blockhash:"",lastValidBlockHeight:0},this.currentBlockHashCount=0,this.maxBlockHashCount=10}async getLatestBlockhash(s){return await this.updateLatestBlockhash(s),this.clearTimer&&global.clearInterval(this.clearTimer),this.clearTimer=global.setInterval(()=>{this.getLatestBlockhash(s)},25e3),this.lastBlockHash}async updateLatestBlockhash(s){try{if(102!==s.get().chainID)return this.lastBlockHash;const t=await s.getProviderByChain(102);if(t){const s=await t.getLatestBlockhash();if(s&&s.blockhash)return this.lastBlockHash=s,this.currentBlockHashCount=0,s}throw new Error("Can't get latest blockhash")}catch(t){return this.currentBlockHashCount<this.maxBlockHashCount?new Promise(t=>{setTimeout(async()=>{try{this.currentBlockHashCount++;const e=await this.updateLatestBlockhash(s);return t(e),e}catch(s){}},1e3)}):this.lastBlockHash}}stopLatestBlockhash(){this.clearTimer&&global?.clearInterval(this.clearTimer)}startLatestBlockhash(s){this.getLatestBlockhash(s)}async swapRoute(t,e){const a=BigInt(t.amountIn)-BigInt(t.dexFeeAmount);const r=`/gmgn/defi/router/v1/sol/tx/get_swap_route?token_in_address=${t.in.address}&token_out_address=${t.out.address}&in_amount=${a}&from_address=${e}&slippage=${100*t.slipPersent}&fee=0.0001&is_anti_mev=false`,o=await s.get(r);if(200===o.status&&0===o.data?.code){const{quote:s,raw_tx:t}=o.data.data;return{success:!0,swapTransaction:t.swapTransaction,recentBlockhash:t.recentBlockhash,outAmount:s.outAmount,data:{...s}}}if(200===o.status&&0!==o.data?.code)throw new Error(JSON.stringify(o.data));throw new Error("Error API get_swap_route"+JSON.stringify(o||{}))}async submitSwap(e,a){try{const r=Buffer.from(a.serialize()).toString("base64"),o=a.signatures.map(s=>t.encode(s)),n=await s.post("/gmgn/txproxy/v1/send_transaction",{chain:"sol",signedTx:r,isAntiMev:!1});if(200===n.status&&0===n.data?.code)return{success:!0,hash:o[0],currentSymbol:e,data:{errorMessage:""}};if(200===n.status&&0!==n.data?.code)throw new Error(n.data.msg);throw new Error("Error API submit_signed_transaction"+JSON.stringify(n))}catch(s){return console.log("submitSwap error",s),{success:!1,hash:"",currentSymbol:e,data:{errorMessage:"极速模式交易发送失败，Error url: /txproxy/v1/send_transaction；"+s+n(s)}}}}async submitSwapFastByBlox(e,a){try{const r=Buffer.from(a.serialize()).toString("base64"),o=a.signatures.map(s=>t.encode(s)),n=await s.post("/bloxApi3/api/v2/submit",{transaction:{content:r},skipPreFlight:!0,frontRunningProtection:!1,fastBestEffort:!1,useStakedRPCs:!0},{headers:{...i()}});if(console.log("submitSwapFastByBlox",n),200===n.status&&n.data?.signature)return{success:!0,hash:o[0],currentSymbol:e,data:{hash:o[0],errorMessage:"",swapHash:o[0]}};throw new Error("Error API bloxApi3"+JSON.stringify(n))}catch(s){return console.log("submitSwap error",s),{success:!1,hash:"",currentSymbol:e,data:{errorMessage:"极速模式交易发送失败，Error url: /bloxApi3/api/v2/submit；"+s+n(s)}}}}async submitSwapFastByFlashblock(s,t){const{success:e,hash:a,data:r}=await this.submitSwapByFlashblockCommon([t],!1);return{success:e,hash:a,currentSymbol:s,data:r}}async submitByQuiknode(){}async submitSwapByJito(e){const o=(new Date).getTime();let i="";try{const n=[...r,...a],c=Buffer.from(e[0].serialize()).toString("base64");let l=e[0].signatures.map(s=>t.encode(s)),u=l;const h=[];if(e.length>=4){for(const s of e)h.push(Buffer.from(s.serialize()).toString("base64"));u=e[1].signatures.map(s=>t.encode(s)),l=e[2].signatures.map(s=>t.encode(s))}const m={jsonrpc:"2.0",id:1,...1===e.length?{method:"sendTransaction",params:[c,{encoding:"base64"}]}:{method:"sendBundle",params:[h,{encoding:"base64"}]}};i=1===e.length?"transactions":"bundles";const d=n.map(t=>s.post(`${t}/${t.includes("quiknode")?"":i}`,m).then(s=>(Promise.resolve(s),s)).catch(s=>(console.log("submitSwapByJito error",s),Promise.reject(s)))),g=await Promise.any(d);return console.log("submitSwapByJito results",g),200===g.status&&g?.data?.result?{success:!0,hash:l[0],data:{errorMessage:null,swapHash:u[0],jitoBundle:[g?.data?.result],submitPostTime:o,lastBlockHash:this.lastBlockHash}}:{success:!1,hash:"",data:{errorMessage:"Error API submitSwapByJito"+JSON.stringify(g),lastBlockHash:this.lastBlockHash}}}catch(s){if(console.log("SendBundle error",s),s instanceof AggregateError&&s?.errors?.length){const t=s.errors[0];if(t?.response?.data)return{success:!1,hash:"",data:{errorMessage:`防夹模式交易发送失败，Error url: ${i};`+JSON.stringify(t.response?.data),lastBlockHash:this.lastBlockHash}}}return{success:!1,hash:"",data:{errorMessage:`防夹模式交易发送失败，Error url: ${i}; error：${s}, ${n(s)}`,lastBlockHash:this.lastBlockHash}}}}async submitSwapByBlox(e){const a=(new Date).getTime();let r="";try{const o=["/bloxApi3/api/v2/"],n=Buffer.from(e[0].serialize()).toString("base64");let c=e[0].signatures.map(s=>t.encode(s)),l=c;const u=[];if(e.length>=4){for(const s of e)u.push({transaction:{content:Buffer.from(s.serialize()).toString("base64")}});l=e[1].signatures.map(s=>t.encode(s)),c=e[2].signatures.map(s=>t.encode(s))}const h=1===e.length?{transaction:{content:n},frontRunningProtection:!0,fastBestEffort:!0,skipPreFlight:!0}:{entries:u,useBundle:!0};r=1===e.length?"submit":"submit-batch";const m=o.map(t=>s.post(t+r,h,{headers:{...i()}}).then(s=>(Promise.resolve(s),s)).catch(s=>(console.log("submitSwapByBlox error",s),Promise.reject(s)))),d=await Promise.any(m);if(console.log("submitSwapByBlox results",d),200===d.status&&(d?.data?.signature||d?.data?.transactions))return{success:!0,hash:c[0],data:{errorMessage:null,hash:c[0],swapHash:l[0],jitoBundle:[],submitPostTime:a,lastBlockHash:this.lastBlockHash}};throw new Error("submitSwapByBlox Error: "+JSON.stringify(d))}catch(s){if(console.log("Blox Error",s),s instanceof AggregateError&&s?.errors?.length){const t=s.errors[0];if(t?.response?.data)return Promise.reject({success:!1,hash:"",data:{errorMessage:`防夹/极速模式交易发送失败，Error url: ${r};`+JSON.stringify(t.response?.data),lastBlockHash:this.lastBlockHash}})}return Promise.reject({success:!1,hash:"",data:{errorMessage:`防夹/极速模式交易发送失败，Error url: ${r}; error：${s}, ${n(s)}`,lastBlockHash:this.lastBlockHash}})}}async submitSwapByFlashblock(s){return await this.submitSwapByFlashblockCommon(s,!0)}async submitSwapByFlashblockCommon(e,a=!0){const r=(new Date).getTime();try{const o=["/flashblockApi/api/v2/submit-batch"],n=Buffer.from(e[0].serialize()).toString("base64");let c=e[0].signatures.map(s=>t.encode(s)),l=c;const u=[];if(e.length>=4){for(const s of e)u.push(Buffer.from(s.serialize()).toString("base64"));l=e[1].signatures.map(s=>t.encode(s)),c=e[2].signatures.map(s=>t.encode(s))}const h=o.map(t=>s.post(t,{transactions:u.length>0?u:[n],mev:a},{headers:{Authorization:"ce2f86fc590c4fca",...i()}}).then(s=>(Promise.resolve(s),s)).catch(s=>(console.log("submitSwapByFlashblock error",s),Promise.reject(s)))),m=await Promise.any(h);if(console.log("submitSwapByFlashblock results",m),200===m.status&&200===m?.data?.code)return{success:!0,hash:c[0],data:{errorMessage:null,hash:c[0],swapHash:l[0],jitoBundle:[],submitPostTime:r,lastBlockHash:this.lastBlockHash,mev:a}};throw new Error("submitSwapByFlashblock Error: "+JSON.stringify(m))}catch(s){if(console.log("submitSwapByFlashblock Error",s),s instanceof AggregateError&&s?.errors?.length){const t=s.errors[0];t?.response?.data&&Promise.reject({success:!1,hash:"",data:{errorMessage:"submitSwapByFlashblock url: ;"+JSON.stringify(t.response?.data),lastBlockHash:this.lastBlockHash,mev:a}})}return Promise.reject({success:!1,hash:"",data:{errorMessage:`submitSwapByFlashblock url: ; error：${s}, ${n(s)}`,lastBlockHash:this.lastBlockHash,mev:a}})}}async submitSwapByAllPlatforms(s,e){const a=[],r=[];return e.forEach((e,o)=>{const n=[];0===o?1===e.length?(n.push(t.encode(e[0].signatures[0])),r.push(this.submitSwapByBlox(e))):(n.push(t.encode(e[1].signatures[0])),n.push(t.encode(e[2].signatures[0])),r.push(this.submitSwapByBlox(e))):1===o&&(1===e.length?(n.push(t.encode(e[0].signatures[0])),r.push(this.submitSwapFastByFlashblock(s,e[0]))):(n.push(t.encode(e[1].signatures[0])),n.push(t.encode(e[2].signatures[0])),r.push(this.submitSwapByFlashblock(e)))),a.push(n)}),Promise.any(r).then(s=>(console.log("submitResult",s),s.success?{success:!0,hashs:a,data:s.data}:{success:!1,hashs:[],data:s.data})).catch(s=>(console.log("submitSwapByAllPlatforms error",s),{success:!1,hashs:[],data:s?.data||s}))}async handlerJitoPost(t,e){for(const a of t)try{await new Promise(s=>setTimeout(s,1e3)),await s.post(a,e)}catch(s){console.log("handlerJitoPost error",s)}}async getSwapStatus(t){try{const e=this.lastBlockHash,a=`/gmgn/defi/router/v1/sol/tx/get_transaction_status?hash=${t}&last_valid_height=${e?.lastValidBlockHeight}`,r=await s.get(a,{timeout:1e3});if(200===r.status&&0===r.data?.code){const{data:s}=r.data;return s.success&&!s.err?"Confirmed":s.failed||s.expired?"Failed":"Pending"}throw new Error("Get Transaction Status Error")}catch(s){return console.log("getSwapStatus error",s),Promise.reject(s)}}async bundlesStatuses(s){try{if(console.log("bundlesStatuses --data",s),!s?.length)return"Pending";const t=await(await fetch("https://mainnet.block-engine.jito.wtf/api/v1/getBundleStatuses",{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({jsonrpc:"2.0",id:1,method:"getBundleStatuses",params:[s]})})).json();if(t?.result?.value?.length){return"Confirmed"===(["processed","confirmed","finalized"].includes(t.result.value[0]?.confirmation_status)?"Confirmed":"Pending")?"Confirmed":"Pending"}return"Pending"}catch(s){return console.log("bundlesStatuses --error",s),Promise.reject(s)}}async rpcSwapStatus(s,t){try{const e=await t.getSignatureStatus(s,{searchTransactionHistory:!0});return"confirmed"!==e?.value?.confirmationStatus&&"finalized"!==e?.value?.confirmationStatus||e?.value?.err?e?.value?.err?"Failed":"Pending":"Confirmed"}catch(s){return console.log("rpcSwapStatus error",s),Promise.reject(s)}}async rpcHeliusSwapStatus(s){const t=new e("https://mainnet.helius-rpc.com/?api-key=e1f7e962-4c6b-40c2-9852-f35189c3ccd7",{commitment:"confirmed"});try{const e=await t.getSignatureStatus(s,{searchTransactionHistory:!0});return"confirmed"!==e?.value?.confirmationStatus&&"finalized"!==e?.value?.confirmationStatus||e?.value?.err?e?.value?.err?"Failed":"Pending":"Confirmed"}catch(s){return Promise.reject(s)}}establishingConnection(){[...r,...a].forEach(t=>{const e=t.match(o);e&&s.get(e[0])})}}export default new c;