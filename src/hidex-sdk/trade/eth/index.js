import{BigNumber as e,ethers as t}from"ethers";import{mTokenAddress as r}from"../../common/config";import a from"../../common/abis";import{getBaseFeePerGas as o,getUseGasPrice as n}from"./utils";import{NETWORK_FEE_RATES as s,networkWeight as i}from"./config";import{abiInFun as c,actionNameAndValue as m}from"./abiFun";export const ethService=l=>{const{network:u,wallet:d}=l;return{getBalance:async(e,o="")=>{const n=u.get();if(!o||o.toLowerCase()===r.toLowerCase()){const t=u.sysProviderRpcs[n.chain].map(t=>t.getBalance(e).then(e=>e).catch(e=>Promise.reject(e))),r=await Promise.any(t);return r.error?"0":r.toString()}if(o){const r=u.sysProviderRpcs[n.chain].map(r=>{const n=new t.Contract(o,a.tokenABI,r);return()=>n.balanceOf(e).then(e=>e).catch(e=>Promise.reject(e))}),s=await Promise.any(r.map(e=>e()));return s.error?"0":s}return"0"},getBalanceMultiple:async(e,r,o)=>{try{const n=await u.get(e);if(0!==Object.entries(u.sysProviderRpcs).length||u.sysProviderRpcs[e]){const s=u.sysProviderRpcs[e].map(e=>{const s=new t.Contract(n.deTrade,a.chillSwapABI,e);return()=>s.callStatic.getTokensBalance(r,o).then(e=>e.length>0?(Promise.resolve(e),e):Promise.reject([])).catch(e=>Promise.reject(e))}),i=await Promise.any(s.map(e=>e()));if(i.error)throw new Error(i.error);return i.map(e=>e.toString())}{const s=await u.getFastestProviderByChain(e),i=new t.Contract(n.deTrade,a.chillSwapABI,s);return(await i.callStatic.getTokensBalance(r,o)).map(e=>e.toString())}}catch(e){return console.log("getBalanceMultiple error",e),o.map(()=>"0")}},getNetWorkFees:async r=>{const a=u.get(),c=a.tokens[0].symbol,m=await o(u);let l="",d="0";if("0"===m){const e=await n(u,r);l=e.gasFeeETH,d=e.gasPriceWei}const h=(o,n)=>{if("0"===o)return{value:parseFloat(l)*n,maxFeePerGas:e.from(0),maxPriorityFeePerGas:e.from(0)};const s=t.utils.parseUnits((Number(o)/10**9*n).toFixed(4),"gwei"),c=e.from(o).add(s).mul(e.from(Math.floor(100*i).toString())).div("100"),m="ETH"===a.chain?c.mul(r):c.mul(r).mul(e.from(150..toString())).div("100");return{value:Number(t.utils.formatEther(m)),maxFeePerGas:c.toString(),maxPriorityFeePerGas:s.toString()}},w=(e,t,r)=>"0"===e.toString()?String(Math.floor(parseFloat(t.toString())*r)):"0",P=u.get(),g=s[P.chain];return[{value:1*h(m,g[0]).value,maxPriorityFeePerGas:h(m,g[0]).maxPriorityFeePerGas,maxFeePerGas:h(m,g[0]).maxFeePerGas,gasPrice:w(m,d,g[0]),gasLimit:r,unit:c,rate:g[0]},{value:1*h(m,g[1]).value,maxPriorityFeePerGas:h(m,g[1]).maxPriorityFeePerGas,maxFeePerGas:h(m,g[1]).maxFeePerGas,gasPrice:w(m,d,g[1]),gasLimit:r,unit:c,rate:g[1]},{value:1*h(m,g[2]).value,maxPriorityFeePerGas:h(m,g[2]).maxPriorityFeePerGas,maxFeePerGas:h(m,g[2]).maxFeePerGas,gasPrice:w(m,d,g[2]),gasLimit:r,unit:c,rate:g[2]}]},getAllowance:async(e,o,n)=>{if(e.toLowerCase()===r.toLowerCase())return t.constants.MaxUint256.toNumber();const s=u.get(),i=u.sysProviderRpcs[s.chain].map(r=>{const s=new t.Contract(e,a.tokenABI,r);return()=>s.allowance(o,n).then(e=>e).catch(e=>Promise.reject(e))}),c=await Promise.any(i.map(e=>e()));if(c.error)throw new Error(c.error);return c},toApprove:async(e,r,o,n)=>{try{const s=u.get(),i=n||t.constants.MaxUint256,c=await d.ownerKey(r),m=u.sysProviderRpcs[s.chain].map(r=>{const n=new t.Contract(e,a.tokenABI,r),s=new t.Wallet(c,r),m=n.connect(s);return()=>m.approve(o,i).then(e=>e).catch(e=>Promise.reject(e))}),l=await Promise.any(m.map(e=>e()));if(console.log("Approve tx:",l),l.error)throw new Error(l.error);return await l.wait(),!0}catch(e){throw console.error("Approval failed:",e),new Error(e.message||"Approval failed")}},getSendEstimateGas:async e=>{const{from:r,to:o,amount:n,tokenAddress:s}=e,i={gasLimit:21e3},c=u.get();if(s&&s!==c.tokens[0].address){const e=u.sysProviderRpcs[c.chain].map(e=>{const i=new t.Contract(s,a.tokenABI,e).interface.encodeFunctionData("transfer",[o,n]),c={to:s,data:i,from:r};return()=>e.estimateGas(c).then(e=>e).catch(e=>Promise.reject(e))}),i=await Promise.any(e.map(e=>e()));if(i.error)throw new Error(i.error);return{gasLimit:Math.floor(1.01*i.toNumber())}}return i},getSendFees:async e=>{const{value:t}=e;return t},sendTransaction:async e=>{const{from:r,to:o,amount:n,tokenAddress:s,currentNetWorkFee:i}=e;console.time("sendTransaction");const{gasLimit:c,maxPriorityFeePerGas:m,maxFeePerGas:l,gasPrice:h}=i,w=u.get(),P=await d.ownerKey(r),g=await u.getFastestProviderByChain(w.chain),p=new t.Wallet(P,g);let y={};const f=Math.floor(c);if(y="0"===h?{gasLimit:f,type:2,maxPriorityFeePerGas:m,maxFeePerGas:l}:{gasLimit:f,gasPrice:h},s&&s!==w.tokens[0].address){const e={to:s,data:new t.Contract(s,a.tokenABI,p).interface.encodeFunctionData("transfer",[o,n])},r=await p.sendTransaction({...e,...y});return console.timeEnd("sendTransaction"),{error:null,result:r}}{const e={to:o,value:n},t=await p.sendTransaction({...e,...y});return console.timeEnd("sendTransaction"),{error:null,result:t}}},getSwapPath:async e=>{if(parseFloat(e?.amountIn.toString())<=0)throw new Error("amountIn must be greater than 0");const o=u.get();let n=e.in.address,s=e.out.address;e.in.address.toLowerCase()===r.toLowerCase()&&(n=o.tokens[1].address),e.out.address.toLowerCase()===r.toLowerCase()&&(s=o.tokens[1].address);const i=u.sysProviderRpcs[o.chain].map(r=>{const i=new t.Contract(o.deTrade,a.chillSwapABI,r);return()=>i.callStatic.getOptimalPath(n,e.amountIn,s).then(e=>e).catch(e=>Promise.reject(e))}),c=await Promise.any(i.map(e=>e()));if(c.error)throw new Error(c.error);if(2===c?.length){const e=c[0];let t="";return 84===e?.length&&(t=e.substring(0,42)),{fullAmoutOut:c[1],data:c[0],authorizationTarget:t}}throw new Error("getSwapPath Error")},getSwapEstimateGas:async(e,r,a)=>{const o=await d.ownerKey(a),n=u.get(),{amountIn:s,amountOutMin:i}=e,{action:l,value:h}=m(e.in.address,e.out.address,s),w=new t.utils.Interface(c[l]).encodeFunctionData(l,[s,i,r.data,e.signature,e.contents]),P={chainId:n.chainID,from:a,to:n.deTrade,value:h,data:w},g=u.sysProviderRpcs[n.chain].map(e=>{const r=new t.Wallet(o,e);return()=>r.estimateGas(P).then(e=>e).catch(e=>Promise.reject(e))}),p=await Promise.any(g.map(e=>e()));if(p.error)throw new Error(p.error);if(p){return{data:w,path:r,gasLimit:Math.floor(1*p.toNumber())}}throw new Error("GetLimit Error")},getSwapFees:async e=>{const{networkFee:t,dexFeeAmount:r}=e;return t?t.value+Number(r)/Math.pow(10,e.isBuy?e.in.decimals:e.out.decimals):0},swap:async(e,r,a)=>{const o=u.get(),n=await u.getClipProviderByChain(o.chain),{gasLimit:s,data:i}=r,c=await d.ownerKey(a),l=new t.Wallet(c,n),{amountIn:h,networkFee:w}=e,{value:P}=m(e.in.address,e.out.address,h),g={chainId:o.chainID,from:a,to:o.deTrade,value:P,data:i},p=w?.gasPrice;let y={};y=p&&"0"!==p?{...g,gasPrice:p}:{...g,maxFeePerGas:w?.maxFeePerGas,maxPriorityFeePerGas:w?.maxPriorityFeePerGas,type:2};const f={...y,gasLimit:Math.floor(1.05*s)},F=await l.sendTransaction(f);return console.timeEnd("tradeTimer"),{error:!F.hash,result:{hash:F.hash,data:{accountAddress:a,currentSymbol:e}}}},claimCommission:async e=>(console.log("claimCommission===>",e),Promise.resolve({data:null,code:200,message:"success"})),hashStatus:async(e,t)=>{let r=t;"number"==typeof t&&(r=u.getChainNameByChainId(t));const a=u.sysProviderRpcs[r].map(t=>t.getTransaction(e).then(e=>e&&e.hash?e:Promise.reject("error hash")).catch(e=>Promise.reject(e))),o=await Promise.any(a);return console.log("statusResult===>",o),o?.confirmations>=2?{status:"Confirmed"}:{status:"Pending"}},hashsStatus:async()=>await Promise.reject({status:"Pending"})}};